#!/usr/bin/env python3

import math
import json
import argparse

import sys


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def float_range(mini, maxi):
    """
    Return function handle of an argument type function for
    ArgumentParser checking a float range: mini <= arg <= maxi
        mini - minimum acceptable argument
        maxi - maximum acceptable argument

    Copyright (C): StackOverflow user Georg W.
    https://stackoverflow.com/a/64259328/7030275
    """

    # Define the function with default arguments
    def float_range_checker(arg):
        """
        New Type function for argparse - a float within predefined range.
        """
        try:
            f = float(arg)
        except ValueError:
            raise argparse.ArgumentTypeError("must be a floating point number")
        if f < mini or f > maxi:
            raise argparse.ArgumentTypeError(
                "must be in range [" + str(mini) + " .. " + str(maxi)+"]")
        return f

    # Return function handle to checking function
    return float_range_checker
#-- float_range


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument('infile',
                        default='/dev/stdin',
                        nargs='?',
                        help="The file to read (if not provided, reads from stdin)",
                        )

    parser.add_argument('-o', '--outfile',
                        default='/dev/stdout',
                        help="The file to output (if not provided, saves to stdout)",
                        )

    parser.add_argument('-r', '--runtime-fraction',
                        default='.95',
                        type=float_range(0, 1),
                        help="The fraction of the runtime it should actually run for",
                        )

    parser.add_argument('-d', '--min-duration',
                        default='20',
                        type=int,
                        help="The minimum duration in seconds of the taskset exectution",
                        )

    parser.add_argument('-c', '--calibration',
                        default='56',
                        type=int,
                        help="The calibration for RT-APP, see RT-App documentation for how to obtain a calibration number for each CPU core type\n\nNOTE: for calibration use:\nFor LITTLE cores at 1.4 GHz -> 204\nFor big cores at 1.4 GHz -> 80"
                        )

    parser.add_argument('-q', '--quota',
                        default='.95',
                        type=float,
                        help="The maximum utilization quota that can be allocated to this taskset. For some reason, tasksets generated by taskgen, even when checked using bash, create utilizations that exceed the quota. This option is to enforce that quota."
                        )

    # parser.add_argument('-l', '--log-suffix',
    #     default='',
    #     type=str,
    #     help="A string that will be appended to the filename for rt-app logs",
    # )

    return parser.parse_args()
#-- parse_args


def lcm(a, b):
    try:
        return math.lcm(a, b)
    except AttributeError:
        return a * b // math.gcd(a, b)
#-- lcm


def timer2secs(timer):
    return int(timer / 1000000.0)


def secs2timer(secs):
    return int(secs * 1000000.0)


def main():
    args = parse_args()

    infile = open(args.infile, 'r')
    outfile = open(args.outfile, 'w')

    out = {
        'tasks': {},
        'global': {
            'duration': 0,  # set this parameter using the hyperperiod
            'default_policy': 'SCHED_DEADLINE',
            'calibration': args.calibration,
            'pi_enabled': False,
            'lock_pages': True,
            'logdir': '/tmp/rt-app-logs',
            'log_basename': 'rt-app',
            'log_size': 'auto',
            'gnuplot': False,
        },
    }

    i = 0
    hyperperiod = 1
    util = 0.0
    for line in infile:
        line = line.rstrip()
        if not line:
            continue
        # For each nonempty line

        # TODO: original implementation ordered by task period, is it needed?

        values = line.split()
        runtime = int(values[0])
        period = int(values[1])
        out['tasks']['task' + str(i).zfill(2)] = {
            'run': int(runtime * args.runtime_fraction),
            'timer': {
                'period': period,
                'mode': 'absolute',
                'ref': 'unique',
            },
            'dl-runtime': runtime,
            'dl-period': period,
            'delay': 500000,
        }

        util += (runtime / period)
        hyperperiod = lcm(hyperperiod, period)
        i += 1
    # for

    while util >= args.quota:
        exceed = util - args.quota

        umax = 0
        uargmax = -1
        found = False

        # Fix so that the utilization does not exceed the maximum quota!
        for j in range(i):
            runtime = out['tasks']['task' + str(j).zfill(2)]['dl-runtime']
            period = out['tasks']['task' + str(j).zfill(2)]['dl-period']

            u = (runtime / period)
            sub = int((exceed * period) + 1)

            if u > umax:
                umax = u
                uargmax = j

            if u > exceed and sub < runtime:
                found = True
                runtime -= sub
                out['tasks']['task' + str(j).zfill(2)]['dl-runtime'] = runtime
                break
        # for

        if not found:
            # Reduce the utilization of the biggest task
            j = uargmax
            runtime = out['tasks']['task' + str(j).zfill(2)]['dl-runtime']
            out['tasks']['task' + str(j).zfill(2)
                         ]['dl-runtime'] = int(runtime * .99)
            #eprint("DEBUG: was ", runtime, " became ", int(runtime * .99))
        # if

        # Re-calculate utilization
        util = 0
        for j in range(i):
            runtime = out['tasks']['task' + str(j).zfill(2)]['dl-runtime']
            period = out['tasks']['task' + str(j).zfill(2)]['dl-period']
            util += (runtime / period)
        # for
    # while

    # Update the run values (just in case the runtime was updated)
    for j in range(i):
        runtime = out['tasks']['task' + str(j).zfill(2)]['dl-runtime']
        out['tasks']['task' +
                     str(j).zfill(2)]['run'] = int(runtime * args.runtime_fraction)
    # for

    hyperperiod = timer2secs(hyperperiod)
    hyperperiod = max(20, hyperperiod)   # min 20 seconds
    hyperperiod = min(600, hyperperiod) # max 10 minutes
    out['global']['duration'] = hyperperiod
    # out['global']['logdir'] += args.log_suffix

    eprint("Duration:", hyperperiod, 's')

    json.dump(out, outfile, indent=2)

    infile.close()
    outfile.close()
# main


if __name__ == "__main__":
    main()
