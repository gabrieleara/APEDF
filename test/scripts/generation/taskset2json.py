#!/usr/bin/env python3

import math
import json
import argparse
import parse

import sys
import numpy as np


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def float_range(mini, maxi):
    """
    Return function handle of an argument type function for
    ArgumentParser checking a float range: mini <= arg <= maxi
        mini - minimum acceptable argument
        maxi - maximum acceptable argument

    Copyright (C): StackOverflow user Georg W.
    https://stackoverflow.com/a/64259328/7030275
    """

    # Define the function with default arguments
    def float_range_checker(arg):
        """
        New Type function for argparse - a float within predefined range.
        """
        try:
            f = float(arg)
        except ValueError:
            raise argparse.ArgumentTypeError("must be a floating point number")
        if f < mini or f > maxi:
            raise argparse.ArgumentTypeError(
                "must be in range [" + str(mini) + " .. " + str(maxi)+"]")
        return f

    # Return function handle to checking function
    return float_range_checker
#-- float_range


def int_range(mini: int, maxi: int):
    """
    Return function handle of an argument type function for
    ArgumentParser checking a int range: mini <= arg <= maxi
        mini - minimum acceptable argument
        maxi - maximum acceptable argument

    Copyright (C): StackOverflow user Georg W.
    https://stackoverflow.com/a/64259328/7030275

    modified by: Gabriele Ara
    """

    # Define the function with default arguments
    def float_range_checker(arg):
        """
        New Type function for argparse - a float within predefined range.
        """
        try:
            f = int(arg)
        except ValueError:
            raise argparse.ArgumentTypeError("must be a floating point number")
        if f < mini or f > maxi:
            raise argparse.ArgumentTypeError(
                "must be in range [" + str(mini) + " .. " + str(maxi)+"]")
        return f

    # Return function handle to checking function
    return float_range_checker
#-- float_range


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument('infile',
                        default='/dev/stdin',
                        nargs='?',
                        help="The file to read (if not provided, reads from stdin)",
                        )

    parser.add_argument('-o', '--outfile',
                        default='/dev/stdout',
                        help="The file to output (if not provided, saves to stdout)",
                        )

    parser.add_argument('-r', '--runtime-fraction',
                        default='.95',
                        type=float_range(0, 1),
                        help="The fraction of the runtime it should actually run for",
                        )

    parser.add_argument('-R', '--runtime-remove',
                        default='0',
                        type=int_range(0, 100000),
                        help="The amount to statically remove from each runtime [us]",
                        )

    parser.add_argument('-m', '--min-duration',
                        default='20',
                        type=int,
                        help="The minimum duration in seconds of the taskset execution",
                        )

    parser.add_argument('-M', '--max-duration',
                        default='600',
                        type=int,
                        help="The maximum duration in seconds of the taskset execution",
                        )

    parser.add_argument('-c', '--calibration',
                        default='56',
                        type=int,
                        help="The calibration for RT-APP, see RT-App documentation for how to obtain a calibration number for each CPU core type\n\nNOTE: for calibration use:\nFor LITTLE cores at 1.4 GHz -> 204\nFor big cores at 1.4 GHz -> 80"
                        )

    parser.add_argument('-q', '--quota',
                        default='.95',
                        type=float,
                        help="The maximum utilization quota that can be allocated to this taskset. For some reason, tasksets generated by taskgen, even when checked using bash, create utilizations that exceed the quota. This option is to enforce that quota."
                        )

    parser.add_argument('-T', '--trace',
                        default=False,
                        action='store_true',
                        help="Enable RTAPP ftrace functionality")

    # parser.add_argument('-l', '--log-suffix',
    #     default='',
    #     type=str,
    #     help="A string that will be appended to the filename for rt-app logs",
    # )

    return parser.parse_args()
#-- parse_args


def lcm(a, b):
    try:
        return math.lcm(a, b)
    except AttributeError:
        return a * b // math.gcd(a, b)
#-- lcm


def timer2secs(timer):
    # From us to s
    return int(timer / 1000000.0)


def secs2timer(secs):
    return int(secs * 1000000.0)


def fix_runtime(amount, args):
    fixed1 = int(amount * args.runtime_fraction)
    fixed2 = int(amount - args.runtime_remove)
    return min(fixed1, fixed2)


def fix_runtimes(taskset, args):
    for task in taskset:
        task['runtime'] = fix_runtime(task['runtime'], args)
    return taskset


def task_name(idx):
    return 'task' + str(idx).zfill(2)


def get_duration(taskset, args):
    hyperperiod = get_hyperperiod(taskset)
    hyperperiod = timer2secs(hyperperiod)
    hyperperiod = max(args.min_duration, hyperperiod)
    hyperperiod = min(args.max_duration, hyperperiod)
    return hyperperiod


def fix_taskset(taskset, args):
    util = tot_util(taskset)
    while util >= args.quota:
        exceed = util - args.quota

        runtime_max = 0
        argmax = -1
        found = False

        # TODO: this fixing mechanism is not so great!

        # Fix so that the utilization does not exceed the maximum quota!
        for i, task in enumerate(taskset):
            taskutil = task_util(task)
            runtime_sub = int((exceed * task['period']) + 1)

            if task['runtime'] > runtime_max:
                runtime_max = task['runtime']
                argmax = i

            if taskutil > exceed and runtime_sub < task['runtime']:
                found = True
                task['runtime'] -= runtime_sub
                break

        if not found:
            # Reduce the runtime of the biggest task and try again
            taskset[argmax]['runtime'] = int(taskset[argmax]['runtime'] * .99)

        # Re-calculate utilization
        util = tot_util(taskset)

    return taskset


def warn_on_too_small(taskset):
    for task in taskset:
        if task['runtime'] < 2000:
            eprint(f"WARN: there is a DL runtime equal to {task['runtime']}!")


def parse_taskset(fname):
    taskset = []
    with open(fname, 'r') as infile:
        for line in infile:
            line = line.rstrip()
            if not line:
                continue  # Skip empty lines
            # Read the two params into a dict
            task_result = parse.parse("{runtime:d} {period:d}", line)
            if task_result is None:
                eprint(
                    f"Error: invalid task specification: '{line}'!")
                sys.exit(1)

            # Get dictionary from parse result
            taskset += [task_result.named]
    return taskset


def task_util(task):
    return task['runtime'] / task['period']


def tot_util(taskset):
    util = 0.0
    for task in taskset:
        util += task_util(task)
    return util


def get_hyperperiod(taskset):
    hyperperiod = 1
    for task in taskset:
        hyperperiod = lcm(hyperperiod, task['period'])
    return hyperperiod


class u64(np.uint64):
    pass


class TooBigTaskRuntimeError(Exception):
    pass


class TasksetCannotBeAcceptedError(Exception):
    pass


DL_BW_SHIFT = u64(20)
DL_BW_UNIT = u64(1) << DL_BW_SHIFT
DL_RATIO_SHIFT = u64(8)
DL_MAX_BW_BITS = u64(64) - DL_BW_SHIFT
DL_MAX_BW = (u64(1) << DL_MAX_BW_BITS) - u64(1)


def dl_to_ratio(runtime: u64, period: u64):
    if runtime > DL_MAX_BW:
        raise TooBigTaskRuntimeError(
            f"{runtime} is too big! Maximum allowed value is {DL_MAX_BW}!")
    return (runtime << DL_BW_SHIFT) // period


DL_NSEC_PER_USEC = u64(1000)
DL_SYSCTL_SCHED_RT_RUNTIME = u64(950000)
DL_SYSCTL_SCHED_RT_PERIOD = u64(1000000)
DL_GLOBAL_RUNTIME = DL_SYSCTL_SCHED_RT_RUNTIME * DL_NSEC_PER_USEC
DL_GLOBAL_PERIOD = DL_SYSCTL_SCHED_RT_PERIOD * DL_NSEC_PER_USEC
DL_GLOBAL_BW = dl_to_ratio(DL_GLOBAL_RUNTIME, DL_GLOBAL_PERIOD)


def check_dl_params(taskset, num_cpus):
    # This check is just to be EXTRA SURE that the taskset will be accepted by
    # SCHED_DEADLINE.
    #
    # It performs the same exact calculation that SCHED_DEADLINE does when
    # testing for tasks acceptance.
    total_bw = u64(0)
    for task in taskset:
        total_bw += dl_to_ratio(u64(task['runtime']), u64(task['period']))

    if DL_GLOBAL_BW * num_cpus < total_bw:
        raise TasksetCannotBeAcceptedError(
            f"The bandwidth {total_bw} is greater than {DL_GLOBAL_BW * num_cpus}")


def main():
    args = parse_args()

    taskset = parse_taskset(args.infile)
    taskset = fix_taskset(taskset, args)
    warn_on_too_small(taskset)
    duration = get_duration(taskset, args)

    # FIXME: change with argument for number of CPUs
    check_dl_params(taskset, 4)

    output_struct = {
        'tasks': {},
        'global': {
            'duration': duration,
            'default_policy': 'SCHED_DEADLINE',
            'calibration': args.calibration,
            'pi_enabled': False,
            'lock_pages': True,
            'logdir': '/mytmp/rt-app-logs',
            'log_basename': 'rt-app',
            'log_size': 'auto',
            'gnuplot': False,
        }
    }

    if args.trace:
        output_struct['global']['ftrace'] = "main,task,loop,event"

    for i, task in enumerate(taskset):
        output_struct['tasks'][task_name(i)] = {
            'run': fix_runtime(task['runtime'], args),
            'timer': {
                'period': task['period'],
                'mode': 'absolute',
                'ref': 'unique',
            },
            'dl-runtime': task['runtime'],
            'dl-period': task['period'],
            'delay': 500000,
        }

    with open(args.outfile, 'w') as outfile:
        json.dump(output_struct, outfile, indent=2)

    return 0
# main


if __name__ == "__main__":
    main()
